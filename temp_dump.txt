from django.test import TestCase, override_settings
from django.urls import reverse
from django.contrib.auth import get_user_model
from django.core import mail
import re


class TwoFactorWizardE2ETest(TestCase):
    @override_settings(USE_2FA=True, EMAIL_BACKEND='django.core.mail.backends.locmem.EmailBackend')
    def test_email_wizard_full_flow_authenticates_user(self):
        User = get_user_model()
        username = 'e2euser'
        password = 'secret'
        email = 'e2e@example.com'
        user = User.objects.create_user(username=username, email=email, password=password)

        # Create a confirmed EmailDevice for the user so the login flow will
        # challenge via email.
        from django_otp.plugins.otp_email.models import EmailDevice
        EmailDevice.objects.create(user=user, name='default', confirmed=True)

        client = self.client

        # Start the login wizard by first fetching the login page to obtain
        # the wizard management hidden fields, then post credentials.
        mail.outbox.clear()
        try:
            login_url = reverse('two_factor:login')
        except Exception:
            try:
                login_url = reverse('accounts:login')
            except Exception:
                login_url = '/account/login/'

        get_resp = client.get(login_url)
        self.assertEqual(get_resp.status_code, 200)

        hidden_inputs = re.findall(r'<input[^>]+type="hidden"[^>]+>', get_resp.content.decode('utf-8'))
        initial_post = {}
        for inp in hidden_inputs:
            name_m = re.search(r'name="([^"]+)"', inp)
            val_m = re.search(r'value="([^"]*)"', inp)
            if name_m:
                initial_post[name_m.group(1)] = val_m.group(1) if val_m else ''

        initial_post.update({'auth-username': username, 'auth-password': password})
        resp = client.post(login_url, initial_post, follow=True)
        self.assertEqual(resp.status_code, 200)

        # Verify an email was sent and extract the token
        self.assertTrue(mail.outbox, 'No email was sent during login challenge')
        body = mail.outbox[-1].body
        m = re.search(r"(\d{6,8})", body)
        self.assertIsNotNone(m, 'No numeric token found in email body')
        token = m.group(1)

        # Collect management form hidden fields from the response context if available
        post_data = {}
        try:
            wizard = resp.context['wizard']
            mgmt = wizard.management_form
            for name in mgmt.fields:
                try:
                    post_data[name] = mgmt[name].value()
                except Exception:
                    post_data[name] = mgmt.initial.get(name, '')
        except Exception:
            hidden_inputs = re.findall(r'<input[^>]+type="hidden"[^>]+>', resp.content.decode('utf-8'))
            for inp in hidden_inputs:
                name_m = re.search(r'name="([^"]+)"', inp)
                val_m = re.search(r'value="([^"]*)"', inp)
                if name_m:
                    post_data[name_m.group(1)] = val_m.group(1) if val_m else ''

        # Merge any remaining hidden inputs and set the token
        hidden_inputs_all = re.findall(r'<input[^>]+type="hidden"[^>]+>', resp.content.decode('utf-8'))
        for inp in hidden_inputs_all:
            name_m = re.search(r'name="([^"]+)"', inp)
            val_m = re.search(r'value="([^"]*)"', inp)
            if name_m and name_m.group(1) not in post_data:
                post_data[name_m.group(1)] = val_m.group(1) if val_m else ''

        post_data['token'] = token

        resp2 = client.post(login_url, post_data, follow=True)
        self.assertEqual(resp2.status_code, 200)
        user_after = resp2.wsgi_request.user
        self.assertTrue(user_after.is_authenticated)
from django.test import TestCase, override_settings
from django.urls import reverse
from django.contrib.auth import get_user_model
from django.core import mail
import re


class TwoFactorWizardE2ETest(TestCase):
    @override_settings(USE_2FA=True, EMAIL_BACKEND='django.core.mail.backends.locmem.EmailBackend')
    def test_email_wizard_full_flow_authenticates_user(self):
        User = get_user_model()
        username = 'e2euser'
        password = 'secret'
        email = 'e2e@example.com'
        user = User.objects.create_user(username=username, email=email, password=password)

        # Create a confirmed EmailDevice for the user so the login flow will
        # challenge via email.
        from django_otp.plugins.otp_email.models import EmailDevice
        device = EmailDevice.objects.create(user=user, name='default', confirmed=True)

        client = self.client

        # Start the login wizard by first fetching the login page to obtain
        # the wizard management hidden fields, then post credentials.
        mail.outbox.clear()
        # Prefer to resolve the namespaced two_factor login URL when available;
        # fall back to the literal account path or the accounts login route.
        try:
            login_url = reverse('two_factor:login')
        except Exception:
            try:
                login_url = reverse('accounts:login')
            except Exception:
                login_url = '/account/login/'

        get_resp = client.get(login_url)
        self.assertEqual(get_resp.status_code, 200)

        # Pull any hidden inputs (including the wizard management form)
        hidden_inputs = re.findall(r'<input[^>]+type="hidden"[^>]+>', get_resp.content.decode('utf-8'))
        initial_post = {}
        for inp in hidden_inputs:
            name_m = re.search(r'name="([^"]+)"', inp)
            val_m = re.search(r'value="([^"]*)"', inp)
            if name_m:
                initial_post[name_m.group(1)] = val_m.group(1) if val_m else ''

        # add credentials (use the form's field names like auth-username/auth-password)
        initial_post.update({'auth-username': username, 'auth-password': password})
        resp = client.post(login_url, initial_post, follow=True)
        self.assertEqual(resp.status_code, 200)

        # The token step should have been rendered and a challenge email sent.
        self.assertTrue(mail.outbox, 'No email was sent during login challenge')
        body = mail.outbox[-1].body
        m = re.search(r"(\d{6,8})", body)
        self.assertIsNotNone(m, 'No numeric token found in email body')
        token = m.group(1)

        # Extract management form hidden fields from the rendered page context
        # (safer than parsing HTML). The wizard form is available in the
        # response context as 'wizard'. Use the management_form bound fields
        # to collect the exact names and values required by formtools.
        post_data = {}
        try:
            wizard = resp.context['wizard']
            mgmt = wizard.management_form
            for name in mgmt.fields:
                # BoundField.value() returns the value to render for the field
                try:
                    post_data[name] = mgmt[name].value()
                except Exception:
                    # fallback to initial or empty
                    post_data[name] = mgmt.initial.get(name, '')
        except Exception:
            # If context isn't available, fall back to HTML parsing (best-effort)
            hidden_inputs = re.findall(r'<input[^>]+type="hidden"[^>]+>', resp.content.decode('utf-8'))
            for inp in hidden_inputs:
                name_m = re.search(r'name="([^"]+)"', inp)
                val_m = re.search(r'value="([^"]*)"', inp)
                if name_m:
                    post_data[name_m.group(1)] = val_m.group(1) if val_m else ''

        # Also merge any hidden inputs from the rendered HTML as a safety net
        # (covers cases where the response context contains a bound management
        # form but additional hidden fields are still present in the HTML).
        hidden_inputs_all = re.findall(r'<input[^>]+type="hidden"[^>]+>', resp.content.decode('utf-8'))
        for inp in hidden_inputs_all:
            name_m = re.search(r'name="([^"]+)"', inp)
            val_m = re.search(r'value="([^"]*)"', inp)
            if name_m and name_m.group(1) not in post_data:
                post_data[name_m.group(1)] = val_m.group(1) if val_m else ''

        # The token form field in the email method is named 'token'
        post_data['token'] = token

        from django.test import TestCase, override_settings
        from django.urls import reverse
        from django.contrib.auth import get_user_model
        from django.core import mail
        import re


        class TwoFactorWizardE2ETest(TestCase):
            @override_settings(USE_2FA=True, EMAIL_BACKEND='django.core.mail.backends.locmem.EmailBackend')
            def test_email_wizard_full_flow_authenticates_user(self):
                User = get_user_model()
                username = 'e2euser'
                password = 'secret'
                email = 'e2e@example.com'
                user = User.objects.create_user(username=username, email=email, password=password)

                # Create a confirmed EmailDevice for the user so the login flow will
                # challenge via email.
                from django_otp.plugins.otp_email.models import EmailDevice
                device = EmailDevice.objects.create(user=user, name='default', confirmed=True)

                client = self.client

                # Start the login wizard by first fetching the login page to obtain
                # the wizard management hidden fields, then post credentials.
                mail.outbox.clear()
                # Prefer to resolve the namespaced two_factor login URL when available;
                # fall back to the literal account path or the accounts login route.
                try:
                    login_url = reverse('two_factor:login')
                except Exception:
                    try:
                        login_url = reverse('accounts:login')
                    except Exception:
                        login_url = '/account/login/'

                get_resp = client.get(login_url)
                self.assertEqual(get_resp.status_code, 200)

                # Pull any hidden inputs (including the wizard management form)
                hidden_inputs = re.findall(r'<input[^>]+type="hidden"[^>]+>', get_resp.content.decode('utf-8'))
                initial_post = {}
                for inp in hidden_inputs:
                    name_m = re.search(r'name="([^"]+)"', inp)
                    val_m = re.search(r'value="([^"]*)"', inp)
                    if name_m:
                        initial_post[name_m.group(1)] = val_m.group(1) if val_m else ''

                # add credentials (use the form's field names like auth-username/auth-password)
                initial_post.update({'auth-username': username, 'auth-password': password})
                resp = client.post(login_url, initial_post, follow=True)
                self.assertEqual(resp.status_code, 200)

                # The token step should have been rendered and a challenge email sent.
                self.assertTrue(mail.outbox, 'No email was sent during login challenge')
                body = mail.outbox[-1].body
                m = re.search(r"(\\d{6,8})", body)
                self.assertIsNotNone(m, 'No numeric token found in email body')
                token = m.group(1)

                # Extract management form hidden fields from the rendered page context
                # (safer than parsing HTML). The wizard form is available in the
                # response context as 'wizard'. Use the management_form bound fields
                # to collect the exact names and values required by formtools.
                post_data = {}
                try:
                    wizard = resp.context['wizard']
                    mgmt = wizard.management_form
                    for name in mgmt.fields:
                        # BoundField.value() returns the value to render for the field
                        try:
                            post_data[name] = mgmt[name].value()
                        except Exception:
                            # fallback to initial or empty
                            post_data[name] = mgmt.initial.get(name, '')
                except Exception:
                    # If context isn't available, fall back to HTML parsing (best-effort)
                    hidden_inputs = re.findall(r'<input[^>]+type="hidden"[^>]+>', resp.content.decode('utf-8'))
                    for inp in hidden_inputs:
                        name_m = re.search(r'name="([^"]+)"', inp)
                        val_m = re.search(r'value="([^"]*)"', inp)
                        if name_m:
                            post_data[name_m.group(1)] = val_m.group(1) if val_m else ''

                # Also merge any hidden inputs from the rendered HTML as a safety net
                # (covers cases where the response context contains a bound management
                # form but additional hidden fields are still present in the HTML).
                hidden_inputs_all = re.findall(r'<input[^>]+type="hidden"[^>]+>', resp.content.decode('utf-8'))
                for inp in hidden_inputs_all:
                    name_m = re.search(r'name="([^"]+)"', inp)
                    val_m = re.search(r'value="([^"]*)"', inp)
                    if name_m and name_m.group(1) not in post_data:
                        post_data[name_m.group(1)] = val_m.group(1) if val_m else ''

                # The token form field in the email method is named 'token'
                post_data['token'] = token

                # Post the token to complete the wizard
                resp2 = client.post(login_url, post_data, follow=True)
                self.assertEqual(resp2.status_code, 200)

        # After successful authentication the test client should be logged in.
        user_after = resp2.wsgi_request.user
        self.assertTrue(user_after.is_authenticated)

